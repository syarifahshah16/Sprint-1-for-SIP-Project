#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.3 on Fri Aug 31 03:44:54 2018
#

import wx
import wx.aui
import os
#import random
import SummaryTab, FileTab, ImagesTab, NewCaseDialog, mainmenu, search, searchTab, SessionsTab, DNSTab, CredentialsTab        

#import connectdb
import database as connectdb

#import subprocess
#import sqlite3
#from sqlite3 import Error
#from pathlib import Path
#import datetime, time
#import re
#from threading import Thread

# relating to extraction of values from PCAP file
# see https://pypi.org/project/dpkt/
import dpkt
#from dpkt.ip import IP
#from dpkt.ethernet import Ethernet
#from dpkt.arp import ARP

#import struct
import socket
#import _thread
import re



# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade



# globals
fileCentric = True # TODO add GUI "switch" so that we can select packet-centric if so desired; e.g. for more detailed analysis or for debug
openTabs = [0]
caseDbPath = None



class mainFrame(wx.Frame):
    def __init__(self, parent):
        # begin wxGlade: mainFrame.__init__
        wx.Frame.__init__(self, parent=parent)
        self.SetSize((1280, 720))
        
        # Menu Bar
        self.frame_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "New case", "")
        self.Bind(wx.EVT_MENU, self.onNewCase, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Open case", "")
        self.Bind(wx.EVT_MENU, self.onOpenCase, id=item.GetId())
        wxglade_tmp_menu.AppendSeparator()
        itemAddEvidenceBtn = wxglade_tmp_menu.Append(wx.ID_ANY, "Add PCAP File", "")                                      
        self.Bind(wx.EVT_MENU, self.onAddEvidence, id=itemAddEvidenceBtn.GetId())     
        wxglade_tmp_menu.AppendSeparator()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Quit", "")
        self.Bind(wx.EVT_MENU, self.onQuit, id=item.GetId())
        self.frame_menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Clear GUI", "")
        self.Bind(wx.EVT_MENU, self.onClearGUI, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Delete Data", "")
        self.Bind(wx.EVT_MENU, self.onDeleteData, id=item.GetId())
        
        """item = wxglade_tmp_menu.Append(wx.ID_ANY, "Network pcap files", "")
        self.Bind(wx.EVT_MENU, self.onSelNetworkPcapFiles, id=item.GetId())"""

        self.frame_menubar.Append(wxglade_tmp_menu, "Tools")
        self.SetMenuBar(self.frame_menubar)
        # Menu Bar end

        #splitter window
        self.window_1 = wx.SplitterWindow(self, wx.ID_ANY)

        #left panel
        self.windowLeftPanel = wx.Panel(self.window_1, wx.ID_ANY)
        self.tree_ctrl_1 = wx.TreeCtrl(self.windowLeftPanel, wx.ID_ANY, style=wx.TR_HAS_BUTTONS | wx.TR_MULTIPLE)
        
        #right panel
        self.windowRightPanel = wx.Panel(self.window_1, wx.ID_ANY)
        self.searchBtn = wx.Button(self.windowRightPanel, id=wx.ID_ANY, label="Search", pos=wx.DefaultPosition, size=(100,-1), style=0, validator=wx.DefaultValidator)
       
        self.auiNotebook = wx.aui.AuiNotebook(self.windowRightPanel)
        self.paneltest = wx.Panel(self.auiNotebook, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL)
        
    
        #bind events
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.onItemSel, self.tree_ctrl_1)
        self.Bind(wx.EVT_BUTTON, self.onSearchBtn, self.searchBtn)
        self.Bind(wx.aui.EVT_AUINOTEBOOK_PAGE_CLOSE, self.onAuiClose, self.auiNotebook)

        #properties
        self.SetTitle("Forensic Pi")
        self.tree_ctrl_1.SetBackgroundColour(wx.Colour(240, 240, 240))
        self.windowLeftPanel.SetMinSize((180, -1))
        self.windowRightPanel.SetMinSize((980, -1))
        self.window_1.SetMinimumPaneSize(20)

        #layout
        mainSizer = wx.BoxSizer(wx.VERTICAL)
        
        #left panel sizer
        panel1Sizer = wx.BoxSizer(wx.HORIZONTAL)
        panel1Sizer.Add(self.tree_ctrl_1, 1, wx.EXPAND, 0)
        self.windowLeftPanel.SetSizer(panel1Sizer)
        
        #right panel sizer
        self.panel2Sizer = wx.BoxSizer(wx.VERTICAL)
        self.panel2Sizer.Add(self.searchBtn, 0, wx.ALIGN_RIGHT , 0)
        self.panel2Sizer.Add(self.auiNotebook, 1, wx.EXPAND, 0)
        self.windowRightPanel.SetSizer(self.panel2Sizer)
        
        #splitter
        self.window_1.SplitVertically(self.windowLeftPanel, self.windowRightPanel)
        mainSizer.Add(self.window_1, 1, wx.EXPAND, 0)
       
        self.SetSizer(mainSizer)
        self.Layout()
        
        # database
        self.conn = None
        #self.evidence = None
        self.evidenceDetails = None



    def recreateTree(self, caseDbFile):
        self.tree_ctrl_1.Freeze()
        self.tree_ctrl_1.DeleteAllItems()
        global caseName
        for x in caseDetails:
            caseName = str(x[2]) + "_" + x[3]

        root = self.tree_ctrl_1.AddRoot(caseName)                                   #adds the name of case as root item in treectrl
        self.tree_ctrl_1.AppendItem(root, "Summary")
       
        #conn = connectdb.create_connection(caseDbFile)                              #connect to case database
        
        # commented-out as not used
        #evidenceInfo = connectdb.select_evidence_details(self.conn)#conn)                      #get evidenceName, EvidenceDbPath EvidenceDatetime and Md5 from case database
                                                                                    #EvidenceDbPath = path to tsk database generated when onAddEvidence is called
        self.tree_ctrl_1.AppendItem(root, "Bookmarks")
        self.tree_ctrl_1.AppendItem(root, "File")
        self.tree_ctrl_1.AppendItem(root, "Images")
        self.tree_ctrl_1.AppendItem(root, "Sessions")
        self.tree_ctrl_1.AppendItem(root, "DNS")
        self.tree_ctrl_1.AppendItem(root, "Credentials")

        self.tree_ctrl_1.ExpandAll()
        self.tree_ctrl_1.Thaw()



    #-----------------
    #menu functions
    #-----------------
    
    def onNewCase(self, event):  
        dialog = NewCaseDialog.newCase(None)
        dialog.Center()
        dialog.ShowModal()
        dbPath = dialog.getCaseDb()
        
        global caseDetails, caseDbPath
        try:
            self.conn = connectdb.create_connection(dbPath) #connects to new case database
            caseDetails = connectdb.select_case_details(self.conn) #get InvestigatorName, CaseNum, CaseName, CaseFolder, CaseDb, CaseDesc, Datatime from case database
            self.recreateTree(dbPath)
            caseDbPath = dbPath
            
        except:
            pass 
        
        dialog.Destroy()
        


    def onOpenCase(self, event):  
        openFileDialog = wx.FileDialog(self, "Open", "", "","*.db",         #creates a filedialog that only allow user to select .db files
                                       wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) 
 
        openFileDialog.ShowModal()                      
        global caseDbPath
        caseDbPath  = openFileDialog.GetPath()                              #get path selected in filedialog
        
        global caseDetails, openTabs
        try:
            #conn = connectdb.create_connection(caseDbPath)                  #try to connect to case database and get case and evidence details
            self.conn = connectdb.create_connection(caseDbPath)
            caseDetails = connectdb.select_case_details(self.conn)#conn)
            self.evidenceDetails = connectdb.select_evidence_details(self.conn)#conn)       #get EvidenceName, EvidenceDbPath, EvidenceDatatime and Md5 from case database
            self.addAuiTab("Summary", self.evidenceDetails)                      #opens summary page 
            openTabs.append("Summary")                          
            self.recreateTree(caseDbPath)
        except:
            pass                                                            #ignore if try: fails
        openFileDialog.Destroy()



    def onAddEvidence(self, event):
        global caseDetails
        
        try:
            caseDetails
            
        except NameError:                                                   #if caseDetails not defined
            print("Case not opened")
            
        else:                                                               #if caseDetails is defined
            openFileDialog = wx.FileDialog(self, "Open", "", "","*.pcap",     #creates a filedialog that only allow user to select .pcap files 
                                        wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
    
            openFileDialog.ShowModal()
            evidencePath = openFileDialog.GetPath()                         #get path of selected dd file
        
            # https://www.tutorialspoint.com/python3/python_multithreading.htm
            self.onAddEvidencePcapExtract(evidencePath, openFileDialog,) 



    def onAddEvidencePcapExtract(self, evidencePath, openFileDialog):
        """relating to extraction of values from PCAP file"""
        global caseDbPath

        if (None == caseDbPath):
            print("Error: onAddEvidencePcapExtract - global caseDbPath invalid!")
            return False
            
        #-------------------
        # PCAP Extraction
        #-------------------
        
        # see http://www.kroosec.com/2012/10/a-look-at-pcap-file-format.html?m=1
        # https://programtalk.com/python-examples/dpkt.ethernet.Ethernet/
        # https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_fields
        # https://jon.oberheide.org/blog/2008/10/15/dpkt-tutorial-2-parsing-a-pcap-file/
        # http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session
        
        print("Starting PCAP extraction")
        print("\n") # just a line of spacing
        
        # to get file path from the evidencePath (MUST CHANGE)
        print("File path: ", evidencePath)
        
        # filename and extension (MUST CHANGE)
        fileName, fileExt = os.path.splitext(os.path.basename(evidencePath))
        print("File name: ", fileName)
        print("File extension: ", fileExt)
        
        # size (MUST CHANGE)
        fileSize =  (os.stat(evidencePath)).st_size
        print("File size: ", fileSize, " bytes")
        
        print("\n") # just a line of spacing
        
        #rb is for opening non-text files
        f = open(evidencePath, 'rb')
        pcap = dpkt.pcap.Reader(f)

        identifier = 0
        httpFileTransferCount = 0;
        
        # make our own connection to the database (and make sure we close it when we're finished)
        # so that we are free to adopt a multihreaded approach if we so desire (and if sqlite3 supports it)
        # https://stackoverflow.com/questions/6296055/serializing-sqlite3-in-python
        addEvidenceDbConn = connectdb.create_connection(caseDbPath)
        
        dbPreBufList = []; # create an empty list into which we'll temporarily store the data to be written to the database
        
        for ts, buf in pcap:
            identifier = identifier + 1
            idStr = "\nPacket identifier: " + str(identifier)
            #print(idStr)
            
            #default values
            protocol    = "HTTP "
            ext         = ""
            size        = ""
            #timestamp   = ""
            fileName    = ""
            evidencePath = ""
            
            #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            #|       Ethernet destination address (first 32 bits)            |
            #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            #| Ethernet dest (last 16 bits)  |Ethernet source (first 16 bits)|
            #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            #|       Ethernet source address (last 32 bits)                  |
            #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            #|        Type code              |                               |
            #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            # Type is a two-octet field in an Ethernet frame.
            # It is used to indicate which protocol is encapsulated 
            # in the payload of the frame. The same field is also used 
            # to indicate the size of some Ethernet frames.
            # This field is used by the data link layer to determine 
            # which protocol to hand over the payload to on the receiving end.
            eth = dpkt.ethernet.Ethernet(buf)
            #print("Ethernet type code: ", eth.type)

            if eth.type == dpkt.ethernet.ETH_TYPE_IP:
                #print("IP packet type detected. Extracting values...")
                #to contain your IP address in binary
                ip_hdr = eth.data
                ip     = eth.ip
                tcp    = ip.data
                
                # Frame number (assumed to be a sequential number which
                # identifies a Ethernet entry within the PCAP)
                frameNumber  = identifier
                
                #------------------------
                # Server to Web Client
                #------------------------
                src_ip_addr_bin = ip_hdr.src
                src_host_str = socket.inet_ntoa(src_ip_addr_bin)
                
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    src_port = tcp.sport
                    #print("Source port: ", src_port)
                    
                    # if the source port is 80 or 443 then we're looking at a Response message
                    # from the server to the web client.
                    if (80 == int(src_port)) and (len(tcp.data) > 0):
                        try:                               
                            http = dpkt.http.Response(tcp.data)
                            content_length = http.headers['content-length'] if 'content-length' in http.headers else ""
                            size = str(content_length)
                            #print("Content length: ", size)
                            protocol = protocol + (http.headers['transfer-encoding'] if 'transfer-encoding' in http.headers else "")
                            
                        except Exception:
                            print(idStr)
                            print("Exception in Response direction")
                            
                    elif (443 == int(src_port)) and (len(tcp.data) > 0 ): # if SSL
                        # https://dpkt.readthedocs.io/en/latest/_modules/dpkt/ssl.html
                        # https://gist.github.com/strizhechenko/3b70da47d317f8f8875d39edbfc5d7fc
                        # https://tools.ietf.org/html/rfc5246#section-7.4.2
                        # https://tls.ulfheim.net/
                        # https://tls.ulfheim.net/certificate.html
                        
                        try:
                            protocol = "TLS Certificate"
                            
                            tls = dpkt.ssl.TLS(tcp.data)
                            if len(tls.records) >= 1:
                                for i in range (0, len(tls.records)):
                                    handshake = dpkt.ssl.TLSHandshake(tls.records[i].data)
                                    if handshake.type == 11:
                                        certificateClassInst = handshake.data
                                        certificate = certificateClassInst.certificates[0] # certificate is str type TODO multiple certificates
                                        data = certificate
                                        
                                        idx = 0
                                        lenData = len(data)
                                        #print("Data length: " + str(lenData))
                                        found = False
                                        while (idx < (lenData - 2)):
                                            Byte1 = data[idx]
                                            Byte2 = data[idx + 1]
                                            #print("Byte 1: " + str(hex(Byte1)) + " Byte 2: " + str(hex(Byte2)))
                                            if (Byte1 == 0x30) and (Byte2 == 0x82): # cert seq or cert info seq
                                                inc = 4
                                            elif (Byte1 == 0x30) and (Byte2 == 0x22): # iss seq
                                                inc = 2
                                            elif (Byte1 == 0x30) and (Byte2 == 0x2b): # subj seq
                                                inc = 2
                                            elif (Byte1 == 0x30) and (Byte2 == 0x4e): # iss seq
                                                inc = 2
                                            else:
                                                inc = Byte2 + 2 # length (+2 to include Byte1 and Byte2)
                                                
                                            #safety check
                                            if inc == 0:
                                                #print("byte sync lost")
                                                break # from while-loop
                                            
                                            if (Byte1 == 0x30) and (Byte2 == 0x81): # start of rdn seq - look for common name
                                                #print("start of rdn seq found")
                                                for i in range (idx +2, len(data) - 7):
                                                    Byte1 = data[i]
                                                    Byte2 = data[i + 1]
                                                    Byte5 = data[i + 4]
                                                    Byte6 = data[i + 5]
                                                    Byte7 = data[i + 6]
                                                    if (Byte1 == 0x30) and (Byte5 == 0x55) and (Byte6 == 0x04) and (Byte7 == 0x03):
                                                        #print("common name found")
                                                        comNameLen = data[i + 8]
                                                        comName = data[i + 9: i + 9 + comNameLen] # i + 9 + comName gives us characters up to i + 9 + comName -1 !
                                                        #print("Common name: " + str(comName))
                                                        src_host_str = src_host_str + " [" + str(comName) + "]"
                                                        found = True
                                            
                                            idx = idx + inc
                                            if True == found:
                                                break # from while-loop
                                            
                                        if False == found:
                                            print(idStr)
                                            print("common name not found")

                        except Exception:
                            print(idStr)
                            print("Exception in SSL web server to client direction")
                        
                else:
                    print(idStr)
                    print("Protocol is not TCP")
                
                #print("Source host: ", src_host_str)
                
                #------------------------
                # Web Client to Server
                #------------------------
                dst_ip_addr_bin = ip_hdr.dst
                dst_host_str = socket.inet_ntoa(dst_ip_addr_bin)
                
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    dst_port = tcp.dport
                    #print("Destination port: ", dst_port)
                    
                    # if the desitnation port is 80 or 443 then we're looking at a Request message
                    # from the web client to the server
                    if (80 == int(dst_port)) and (len(tcp.data) > 0): # if HTTP
                        try:      
                            http = dpkt.http.Request(tcp.data)
                            
                            host = http.headers['host'] if 'host' in http.headers else None
                            dst_host_str = dst_host_str + " [" + str(host) + "]"
                            
                            uri = http.uri
                            evidencePath = str(uri)
                            fileName = os.path.basename(evidencePath)
                            
                            # process extension
                            ext = os.path.splitext(fileName)[1][1:]
                            if len(ext) > 4: # assume extension can't be more than 4 characters in length
                                ext = ext[:4]
                            if ext[3] == '?': # assume extension can't end with '?'
                                ext = ext[:3]
                            if ext[2] == '?':
                                ext = ext[:2]
                            if False == ext.isalpha(): # assume extension can contain only letters
                                ext = " "
                            
                            user_agent = http.headers['user-agent'] if 'user-agent' in http.headers else None
                            src_host_str = src_host_str + " [" + str(user_agent) + "]"
                            
                            protocol = protocol + (http.headers['transfer-encoding'] if 'transfer-encoding' in http.headers else "")
                            
                            if fileName != "":
                                httpFileTransferCount = httpFileTransferCount + 1
                            
                        except Exception:
                            print(idStr)
                            print("Exception in Request direction")
                            
                    elif (443 == int(dst_port)) and (len(tcp.data) > 0 ): # if SSL
                        try:
                            src_host_str = src_host_str + " (Other)"
                            protocol = "TLS Certificate"
                            
                        except Exception:
                            print(idStr)
                            print("Exception in SSL web client to server direction")
                    
                            
                else:
                    print(idStr)
                    print("Protocol is not TCP")
                    
                #print("Desintation host: ", dst_host_str)
                
                #timestamp = ""
                                       
                # Output to database pre-buffer
                if (src_port == 80) or (src_port == 443) or (dst_port == 80) or (dst_port == 443): # only show packets that are to do with file transfers (via port 80 or port 443)
                    self.evidenceDetails = 1 # flag that we've got evidence
                
                    # which the extracted data to the temporary buffer so that we can seperate PCAP extraction from database interfaction
                    dbPreBufList.append( (int(frameNumber), str(evidencePath), str(src_host_str), str(src_port), str(dst_host_str), str(dst_port), str(protocol), str(fileName), str(ext), str(size) ) ) # list of tuples
                
            else:
                print(idStr)
                print("Unsupported packet type. Values not extracted.")
        
        # transfer data (tuples) from buffer to database
        # http://specminor.org/2017/01/09/improve-sqlite-write-speed-python.html
        numRows = len(dbPreBufList)
        #print("Rows: " + str(numRows))
        for i in range (0, numRows, 20): # step size 10
            cursor = addEvidenceDbConn.cursor()
            cursor.execute("PRAGMA synchronous = OFF")
            cursor.execute("BEGIN TRANSACTION")
            for j in range (i, i + 20): # must be same value as for i step size above
                if j >= numRows:
                    break # from for-loop
                    
                r = dbPreBufList[j] # row tuple

                cursor.execute('''INSERT INTO pcapEvidenceTable(frameNum, filePath, srcHost, srcPort, dstHost, dstPort, protocol, filename, ext, size) VALUES(?,?,?,?,?,?,?,?,?,?)''',
                       (r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]))
            
            addEvidenceDbConn.commit()

        print ("\nPCAP extraction finished.\n")
        print ("Packets captured: ", str(identifier))
        print ("HTTP file transfer count: ", httpFileTransferCount)

        addEvidenceDbConn.close()
        openFileDialog.Destroy() # close PCAP file
        
        return True # status = OK



    def onQuit(self, event):
        connectdb.close_connection(self.conn) # close database connection
        self.Close()
        self.Destroy()



    def onClearGUI(self, event):  
        print("Event handler 'onClearGUI' not implemented!")
        event.Skip()



    def onDeleteData(self, event):  
        print("Event handler 'onDeleteData' not implemented!")
        event.Skip()



    #end of menu functions



    #--------------------
    #aui tab functions
    #--------------------
    
    def checkOpenedTab(self, tabName):                     #check if tab is opened in aui
        global openTabs
        
        openedTab = set(openTabs)
        if tabName not in openedTab:
            openTabs.append(tabName)
            return True
        else:
            return False



    def addAuiTab(self, tabName, evidenceDetails):
        global caseDir
        for x in caseDetails:
            caseDir = x[4]

        if tabName == "Summary":
            self.auiNotebook.AddPage(SummaryTab.TabPanel(self.auiNotebook, caseDetails, evidenceDetails), tabName, False, wx.NullBitmap)

        if tabName == "File":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(FileTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)
            
            #sequence = [frameNumber, evidencePath, src_host_str, src_port, dst_host_str, dst_port, protocol, fileName, ext, size, timestamp]
            window = self.auiNotebook.GetPage(self.auiNotebook.GetPageCount() - 1) # we've just added a page so the page we want to access is the last one
            #sequence = [1, "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"]
            #FileTab.TabPanel.addPcapDetails(window, sequence)
            
            # Get the PCAP data from the database and display in the GUI (File tab)
            global fileCentric
            self.pcapDataDbToGui(window, fileCentric,) 

        if tabName == "Images":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(ImagesTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Sessions":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(SessionsTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "DNS":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(DNSTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Credentials":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(CredentialsTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Bookmarks":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)
            LoadingDialog(self._dialog)
            
            # commented-out as AnalyzedDataTab undefined
            #self.auiNotebook.AddPage(AnalyzedDataTab.TabPanel(self.auiNotebook, tabName, evidenceDetails, caseDir, caseDbPath), tabName, False, wx.NullBitmap)  #calls and open a aui tab from SummaryTab.py
            
            LoadingDialog.endLoadingDialog(self)


        # This block remains commented-out because AnalyzedDataTab doesn't exist, and evidenceDbInfo isn't used.
        # Note: this block of code is not fully understood
        """for x in evidenceDetails:                  
            evidenceDbConn = connectdb.create_connection(x[2])                      #connects to tsk database
            evidenceDbInfo = connectdb.select_image_info(evidenceDbConn)            #get name, size and md5 from tsk database
            evidencePart  = connectdb.select_image_partitions(evidenceDbConn)       #get partition info from tsk database
            count = 0
            for i in evidencePart:
                count += 1
                if tabName == "Vol{count} {desc}: {start}-{end})".format(count=count, desc=str(i[2]), start=str(i[0]), end=str(i[1])):
                    self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)
                    LoadingDialog(self._dialog)
                    self.auiNotebook.AddPage(AnalyzedDataTab.TabPanel(self.auiNotebook, tabName, evidenceDetails, caseDir, caseDbPath), tabName, False, wx.NullBitmap)
                    LoadingDialog.endLoadingDialog(self)"""



    def pcapDataDbToGui(self, window, fileCentric):
        if(False == fileCentric) : # packet-centric output
            # Get the PCAP data from the database and display in the GUI (File tab)
            index = 1
            while (True):
                row = connectdb.selectPcapEvidenceDetails(self.conn, index)
                if ( () == row or None == row ):
                    break # from while-loop (no more data)
                    
                FileTab.TabPanel.addPcapDetails(window, row)
                index = index + 1
                
        else: # file-centric
            index = 1 # packet index
            fileIndex = 1

            # column position constants
            sourceHostCol = 2
            destHostCol   = 4
            destPortCol   = 5
            filenameCol   = 7
            sizeCol       = 9
            
            while (True):
                rowTuple = connectdb.selectPcapEvidenceDetails(self.conn, index)
                               
                if ( () == rowTuple or None == rowTuple ):
                    print("End of data")
                    break # from while-loop (no more data)
                    
                if (int(rowTuple[destPortCol]) == 80) or (int(rowTuple[destPortCol]) == 443): # if http port (yes really 80 rather than 0x80!) or ssl
                    if (rowTuple[filenameCol] != ""): # if we have a filename
                        # look for corresponding Response containng file size
                        for j in range(index + 1, index +10): # look through next 10 rows for file size info
                            rowForSizeTuple = connectdb.selectPcapEvidenceDetails(self.conn, j)
                            
                            if ( () == rowTuple or None == rowTuple ):
                                break # from while-loop (no more data)
         
                            # get just the ip address from each host string (ignoring any subsequent characters)
                            destHost          = re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', rowTuple[destHostCol]).group()
                            sourceHost        = re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', rowTuple[sourceHostCol]).group()
                            forSizeDestHost   = re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', rowForSizeTuple[destHostCol]).group()
                            forSizeSourceHost = re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', rowForSizeTuple[sourceHostCol]).group()
                            
                            # compare server and web-client ip addresses to see if we have corresponding http request and response packets
                            if  (forSizeDestHost   == sourceHost)\
                            and (forSizeSourceHost == destHost):
                                # we've found the corresponding Response packet
                                
                                if (rowForSizeTuple[sizeCol] != ""): # if the Response contains a file size then get it
                                    rowTuple = (rowTuple[:sizeCol]) + (rowForSizeTuple[sizeCol],) + rowTuple[sizeCol + 1:]
                                    
                                break # from for-loop (as we've found the Response packet)
                
                        rowTuple = (fileIndex,) + rowTuple[1:] # put fileIndex into Frame Number column
                        fileIndex = fileIndex + 1
                        FileTab.TabPanel.addPcapDetails(window, rowTuple)

                index = index + 1
                
                

    def onItemSel(self, event):  
        temp = event.GetItem()          #gets selected item from treectrl
        print("temp: ", temp)
        tabName = self.tree_ctrl_1.GetItemText(temp)    
        print("{name} selected".format(name=tabName))

        try:
            caseDetails                 #checks if caseDetails is defined
        except:                         #if not defined
            print("Case not opened")
        else:                           #if defined
            try:                    
                self.evidenceDetails #evidenceDetails
            except:
                print("No evidence found")
            else:
                if self.checkOpenedTab(tabName) == True:        #check if selected item is open 
                    self.addAuiTab(tabName, self.evidenceDetails)    #open aui tab
                else: 
                    print('Tab already open')



    def onAuiClose(self, event):
        global openTabs
        
        temp = event.GetSelection()
        tabName = self.auiNotebook.GetPageText(temp)
        self.auiNotebook.RemovePage(temp)
        print("Closing " + tabName + " tab")
        openTabs.remove(tabName)                    #remove closed tab from openTabs
        # TODO work out how to refresh the tab which was in the background

    
    
    def onSearchBtn(self, event):
        try:
            caseDetails
        except:
            print("Case not open")
        else:
            dlg = search.searchDialog(None)         #calls searchDialog() from search.py
            dlg.Center()
            dlg.ShowModal()
            searchItem = dlg.searchItems()          #calls searchItem() to get search and search option

            searchReturn = []
            if searchItem[1] == "Normal Search":
                for x in self.evidenceDetails:
                    conn = connectdb.create_connection(x[2])                            #connect to tsk database
                    searchResults = connectdb.search_file_name(conn, searchItem[0])     #search in tsk database
                    if searchResults != []:
                        for i in searchResults:
                            i = i + (x[1],)                                             #adds image location to end of result
                            searchReturn.append(i)                                      #append each result

                self._dialog = wx.ProgressDialog("Search", "Searching for {val}".format(val=searchItem[0]), 100)
                LoadingDialog(self._dialog)
                self.auiNotebook.AddPage(searchTab.searchTabPanel(self.auiNotebook, searchReturn, caseDir), "Search ("+searchItem[0]+")", False, wx.NullBitmap) #call and add searchTab aui page
                LoadingDialog.endLoadingDialog(self)
            else:
                print("Regular Expression")

            dlg.Destroy()

        

class LoadingDialog():
    def __init__(self, _dialog):
        self._dialog = _dialog
        self._dialog.Center()
        self._dialog.Pulse()
        self.run()
     
    def run(self):
        count = 0
        while True:
            self._dialog.Update(count)
            if count == 100:
                break
            count += 2
        
    def endLoadingDialog(self):
        self._dialog.Destroy()



class MyApp(wx.App):
    def OnInit(self):
        self.ForensicPi = mainFrame(None)
        self.SetTopWindow(self.ForensicPi)
        self.ForensicPi.Show()
        self.ForensicPi.Center()
        mainMenuDialog = mainmenu.dialog(None)
        mainMenuDialog.Center()
        mainMenuDialog.ShowModal()
        
        return True
# end of class MyApp



if __name__ == "__main__":
    forensicPi = None
    forensicPi = MyApp(0)
    if None != forensicPi:
        forensicPi.MainLoop()
    else:
        print("Error in __main__")

